{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Create Component Structure and File Organization",
        "description": "Set up the new component structure with proper file organization according to the PRD specifications.",
        "details": "Create the directory structure as specified in the PRD:\n- Create `src/lib/components/properties-panel/` directory\n- Create empty files for main components:\n  - `PropertiesPanel.svelte` (main container)\n  - `PanelHeader.svelte` (selection info)\n  - `FormField.svelte` (reusable field wrapper)\n- Create `sections/` subdirectory with empty files:\n  - `DimensionsSection.svelte`\n  - `AppearanceSection.svelte`\n  - `EffectsSection.svelte`\n  - `ColorPickerField.svelte`\n\nEnsure proper imports are set up between components. Use Svelte 5 runes syntax for all components.",
        "testStrategy": "Verify that all files are created with proper directory structure. Ensure imports work correctly between components. Run a basic smoke test to confirm the component structure loads without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Reusable FormField Component",
        "description": "Create a reusable FormField component that handles labels, inputs, and accessibility requirements.",
        "details": "Create `FormField.svelte` with the following features:\n- Accept label text, input element, and optional helper text as props\n- Implement proper label associations (for/id)\n- Follow typography scale (field labels: 12px, weight 500)\n- Ensure 8pt grid spacing (4-8px within components)\n- Add aria-describedby for helper text\n- Handle mixed value states with em dash (—) placeholder\n\n```svelte\n<script>\n  import { Label } from \"$lib/components/ui/label\";\n  \n  export let id;\n  export let label;\n  export let helperText = \"\";\n  export let isMixed = false;\n  export let required = false;\n</script>\n\n<div class=\"space-y-2\">\n  <div class=\"flex justify-between items-center\">\n    <Label \n      for={id} \n      class=\"text-xs font-medium text-muted-foreground\"\n      aria-required={required}\n    >\n      {label}\n    </Label>\n    {#if isMixed}\n      <span class=\"text-xs text-muted-foreground\">Mixed values</span>\n    {/if}\n  </div>\n  \n  <div aria-describedby={helperText ? `${id}-description` : undefined}>\n    <slot />\n  </div>\n  \n  {#if helperText}\n    <p id=\"{id}-description\" class=\"text-xs text-muted-foreground\">\n      {helperText}\n    </p>\n  {/if}\n</div>\n```",
        "testStrategy": "Test with various input types to ensure proper rendering. Verify accessibility by checking label associations with browser dev tools. Test mixed value state rendering. Validate WCAG AA compliance for text contrast. Ensure proper spacing according to 8pt grid.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement PanelHeader Component",
        "description": "Create the PanelHeader component that displays selection information and clear button.",
        "details": "Create `PanelHeader.svelte` with the following features:\n- Display selection count and type\n- Add clear selection button\n- Follow typography scale (panel headers: 16px, weight 600)\n- Ensure proper spacing (16px panel padding)\n- Implement focus indicators for interactive elements\n- Ensure minimum 44x44px touch targets for buttons\n\n```svelte\n<script>\n  import { Button } from \"$lib/components/ui/button\";\n  import { X } from \"lucide-svelte\";\n  \n  export let selectionCount = 0;\n  export let selectionType = \"\";\n  export let onClearSelection = () => {};\n  \n  $derived selectionText = selectionCount > 1 \n    ? `${selectionCount} ${selectionType}s selected` \n    : `1 ${selectionType} selected`;\n</script>\n\n<div class=\"flex justify-between items-center pb-4\">\n  <h2 class=\"text-base font-semibold\">{selectionText}</h2>\n  \n  <Button \n    variant=\"ghost\" \n    size=\"icon\" \n    aria-label=\"Clear selection\"\n    class=\"h-11 w-11 focus-visible:ring-2 focus-visible:ring-offset-2\"\n    on:click={onClearSelection}\n  >\n    <X class=\"h-4 w-4\" />\n  </Button>\n</div>\n```",
        "testStrategy": "Verify proper rendering with different selection counts and types. Test clear button functionality. Check focus indicators and keyboard accessibility. Validate touch target size meets 44x44px minimum. Ensure text contrast meets WCAG AA standards.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Main PropertiesPanel Container",
        "description": "Create the main PropertiesPanel container component with accordion sections and proper spacing.",
        "details": "Create `PropertiesPanel.svelte` with the following features:\n- Import and use PanelHeader component\n- Implement ShadCN Accordion for sections\n- Apply 8pt grid spacing system throughout\n- Remove excessive borders, use spacing for separation\n- Ensure proper padding (16px panel padding)\n- Set up reactive state with Svelte 5 runes\n\n```svelte\n<script>\n  import { Accordion, AccordionItem, AccordionContent, AccordionTrigger } from \"$lib/components/ui/accordion\";\n  import { ScrollArea } from \"$lib/components/ui/scroll-area\";\n  import PanelHeader from \"./PanelHeader.svelte\";\n  import DimensionsSection from \"./sections/DimensionsSection.svelte\";\n  import AppearanceSection from \"./sections/AppearanceSection.svelte\";\n  import EffectsSection from \"./sections/EffectsSection.svelte\";\n  \n  // Props\n  export let selectedItems = [];\n  export let onUpdateItems = (items) => {};\n  \n  // Reactive state\n  $derived selectionCount = selectedItems.length;\n  $derived selectionType = selectionCount > 0 ? selectedItems[0].type : \"\";\n  \n  function handleClearSelection() {\n    // Implementation\n  }\n</script>\n\n<div class=\"w-full h-full bg-background border-l border-border\">\n  <ScrollArea class=\"h-full\">\n    <div class=\"p-4 space-y-6\">\n      <PanelHeader \n        selectionCount={selectionCount} \n        selectionType={selectionType}\n        onClearSelection={handleClearSelection}\n      />\n      \n      {#if selectionCount > 0}\n        <Accordion type=\"multiple\" defaultValue={[\"dimensions\", \"appearance\", \"effects\"]} class=\"space-y-4\">\n          <AccordionItem value=\"dimensions\">\n            <AccordionTrigger class=\"text-sm font-medium py-2\">Dimensions</AccordionTrigger>\n            <AccordionContent>\n              <div class=\"pt-4\">\n                <DimensionsSection items={selectedItems} onUpdate={onUpdateItems} />\n              </div>\n            </AccordionContent>\n          </AccordionItem>\n          \n          <AccordionItem value=\"appearance\">\n            <AccordionTrigger class=\"text-sm font-medium py-2\">Appearance</AccordionTrigger>\n            <AccordionContent>\n              <div class=\"pt-4\">\n                <AppearanceSection items={selectedItems} onUpdate={onUpdateItems} />\n              </div>\n            </AccordionContent>\n          </AccordionItem>\n          \n          <AccordionItem value=\"effects\">\n            <AccordionTrigger class=\"text-sm font-medium py-2\">Effects</AccordionTrigger>\n            <AccordionContent>\n              <div class=\"pt-4\">\n                <EffectsSection items={selectedItems} onUpdate={onUpdateItems} />\n              </div>\n            </AccordionContent>\n          </AccordionItem>\n        </Accordion>\n      {:else}\n        <div class=\"text-center text-muted-foreground py-8\">\n          No items selected\n        </div>\n      {/if}\n    </div>\n  </ScrollArea>\n</div>\n```",
        "testStrategy": "Test rendering with various selection states (none, single, multiple). Verify accordion functionality. Check spacing adheres to 8pt grid. Ensure borders are minimized. Test keyboard navigation through accordion sections. Validate scroll behavior with many sections.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement DimensionsSection Component",
        "description": "Create the DimensionsSection component for width, height, position, and rotation controls with mixed value handling.",
        "details": "Create `sections/DimensionsSection.svelte` with the following features:\n- Input fields for width, height, x, y, and rotation\n- Implement mixed value handling with em dash (—)\n- Use FormField component for consistent styling\n- Add increment/decrement with arrow keys\n- Implement proper debouncing (300ms)\n- Use $derived.by() for efficient mixed state computation\n\n```svelte\n<script>\n  import { Input } from \"$lib/components/ui/input\";\n  import FormField from \"../FormField.svelte\";\n  import { debounce } from \"lodash-es\";\n  \n  export let items = [];\n  export let onUpdate = (items) => {};\n  \n  // Compute mixed states efficiently\n  $derived.by(() => {\n    if (items.length === 0) return { width: 0, height: 0, x: 0, y: 0, rotation: 0 };\n    \n    const firstItem = items[0];\n    let width = firstItem.width;\n    let height = firstItem.height;\n    let x = firstItem.x;\n    let y = firstItem.y;\n    let rotation = firstItem.rotation;\n    \n    const hasMixedWidth = items.some(item => item.width !== width);\n    const hasMixedHeight = items.some(item => item.height !== height);\n    const hasMixedX = items.some(item => item.x !== x);\n    const hasMixedY = items.some(item => item.y !== y);\n    const hasMixedRotation = items.some(item => item.rotation !== rotation);\n    \n    return {\n      width: hasMixedWidth ? null : width,\n      height: hasMixedHeight ? null : height,\n      x: hasMixedX ? null : x,\n      y: hasMixedY ? null : y,\n      rotation: hasMixedRotation ? null : rotation,\n      hasMixedWidth,\n      hasMixedHeight,\n      hasMixedX,\n      hasMixedY,\n      hasMixedRotation\n    };\n  });\n  \n  // Debounced update functions\n  const updateWidth = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, width: parseFloat(value) })));\n  }, 300);\n  \n  const updateHeight = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, height: parseFloat(value) })));\n  }, 300);\n  \n  // Similar functions for x, y, rotation\n</script>\n\n<div class=\"space-y-3\">\n  <div class=\"grid grid-cols-2 gap-3\">\n    <FormField id=\"width\" label=\"Width\" isMixed={$derived.hasMixedWidth}>\n      <Input \n        id=\"width\" \n        type=\"number\" \n        value={$derived.width === null ? \"\" : $derived.width} \n        placeholder={$derived.hasMixedWidth ? \"—\" : \"\"}\n        on:input={(e) => updateWidth(e.target.value)}\n        class=\"text-sm\"\n        aria-label=\"Width in pixels\"\n      />\n    </FormField>\n    \n    <FormField id=\"height\" label=\"Height\" isMixed={$derived.hasMixedHeight}>\n      <Input \n        id=\"height\" \n        type=\"number\" \n        value={$derived.height === null ? \"\" : $derived.height} \n        placeholder={$derived.hasMixedHeight ? \"—\" : \"\"}\n        on:input={(e) => updateHeight(e.target.value)}\n        class=\"text-sm\"\n        aria-label=\"Height in pixels\"\n      />\n    </FormField>\n  </div>\n  \n  <!-- Similar implementations for x, y, rotation -->\n</div>\n```",
        "testStrategy": "Test with single and multiple selections to verify mixed value handling. Verify em dash displays correctly for mixed values. Test arrow key increments/decrements. Validate debouncing with performance testing. Check accessibility of numeric inputs. Test applying values to multiple selections.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Professional ColorPickerField Component",
        "description": "Create a professional color picker component with HSB color space, format switching, and contrast checking.",
        "details": "Create `sections/ColorPickerField.svelte` with the following features:\n- 2D color area for saturation/brightness\n- Separate hue slider\n- Separate alpha slider\n- Format switcher (HEX, RGB, HSL, HSB)\n- Copy to clipboard button\n- Recent colors (last 10)\n- Contrast ratio checker with AA/AAA indicators\n- 44x44px minimum touch targets\n- Proper keyboard navigation\n\n```svelte\n<script>\n  import { Popover, PopoverContent, PopoverTrigger } from \"$lib/components/ui/popover\";\n  import { Button } from \"$lib/components/ui/button\";\n  import { Input } from \"$lib/components/ui/input\";\n  import { Tabs, TabsContent, TabsList, TabsTrigger } from \"$lib/components/ui/tabs\";\n  import { Copy, Check } from \"lucide-svelte\";\n  import { calculateContrastRatio, hexToRgb, rgbToHex, rgbToHsl, hslToRgb } from \"../utils/color\";\n  \n  export let color = \"#000000\";\n  export let onChange = (newColor) => {};\n  export let recentColors = [];\n  \n  // State\n  let format = \"hex\";\n  let copied = false;\n  let hue = 0;\n  let saturation = 0;\n  let brightness = 100;\n  let alpha = 100;\n  \n  // Derived values\n  $derived hexValue = rgbToHex(currentRgb);\n  $derived currentRgb = hslToRgb(hue, saturation, brightness, alpha / 100);\n  $derived contrastRatio = calculateContrastRatio(currentRgb, [255, 255, 255]);\n  $derived meetsAA = contrastRatio >= 4.5;\n  $derived meetsAAA = contrastRatio >= 7;\n  \n  // Update color based on format\n  function updateColorFromInput(value) {\n    // Implementation based on format\n  }\n  \n  // Copy to clipboard\n  function copyToClipboard() {\n    navigator.clipboard.writeText(hexValue);\n    copied = true;\n    setTimeout(() => copied = false, 2000);\n  }\n  \n  // Add to recent colors\n  function addToRecentColors() {\n    if (!recentColors.includes(hexValue)) {\n      recentColors = [hexValue, ...recentColors.slice(0, 9)];\n    }\n  }\n</script>\n\n<Popover>\n  <PopoverTrigger asChild>\n    <Button \n      variant=\"outline\" \n      class=\"w-10 h-10 p-0 rounded-md focus-visible:ring-2 focus-visible:ring-offset-2\"\n      style=\"background-color: {hexValue};\"\n      aria-label=\"Select color\"\n    />\n  </PopoverTrigger>\n  \n  <PopoverContent class=\"w-64 p-3\">\n    <div class=\"space-y-3\">\n      <!-- Color area (saturation/brightness) -->\n      <div \n        class=\"w-full h-32 rounded-md cursor-pointer relative\"\n        style=\"background: hsl({hue}, 100%, 50%);\"\n        role=\"slider\"\n        aria-label=\"Color saturation and brightness\"\n        aria-valuemin=\"0\"\n        aria-valuemax=\"100\"\n        tabindex=\"0\"\n      >\n        <!-- Overlay gradients for S/B -->\n        <div class=\"absolute inset-0 bg-gradient-to-r from-white to-transparent\"></div>\n        <div class=\"absolute inset-0 bg-gradient-to-t from-black to-transparent\"></div>\n        \n        <!-- Selection indicator -->\n        <div \n          class=\"absolute w-4 h-4 rounded-full border-2 border-white transform -translate-x-1/2 -translate-y-1/2\"\n          style=\"left: {saturation}%; top: {100 - brightness}%;\"\n        ></div>\n      </div>\n      \n      <!-- Hue slider -->\n      <input \n        type=\"range\" \n        min=\"0\" \n        max=\"360\" \n        bind:value={hue}\n        class=\"w-full h-4 rounded-md appearance-none cursor-pointer\"\n        style=\"background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);\"\n        aria-label=\"Hue\"\n      />\n      \n      <!-- Alpha slider -->\n      <input \n        type=\"range\" \n        min=\"0\" \n        max=\"100\" \n        bind:value={alpha}\n        class=\"w-full h-4 rounded-md appearance-none cursor-pointer\"\n        style=\"background: linear-gradient(to right, transparent, {hexValue});\"\n        aria-label=\"Alpha\"\n      />\n      \n      <!-- Format tabs -->\n      <Tabs value={format} onValueChange={(v) => format = v}>\n        <TabsList class=\"grid grid-cols-4 w-full\">\n          <TabsTrigger value=\"hex\">HEX</TabsTrigger>\n          <TabsTrigger value=\"rgb\">RGB</TabsTrigger>\n          <TabsTrigger value=\"hsl\">HSL</TabsTrigger>\n          <TabsTrigger value=\"hsb\">HSB</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"hex\" class=\"pt-2\">\n          <div class=\"flex\">\n            <Input \n              value={hexValue} \n              on:input={(e) => updateColorFromInput(e.target.value)}\n              class=\"text-sm\"\n              aria-label=\"Hex color value\"\n            />\n            <Button \n              variant=\"ghost\" \n              size=\"icon\" \n              class=\"ml-2 h-10 w-10 focus-visible:ring-2\"\n              on:click={copyToClipboard}\n              aria-label=\"Copy to clipboard\"\n            >\n              {#if copied}\n                <Check class=\"h-4 w-4\" />\n              {:else}\n                <Copy class=\"h-4 w-4\" />\n              {/if}\n            </Button>\n          </div>\n        </TabsContent>\n        \n        <!-- Similar TabsContent for RGB, HSL, HSB -->\n      </Tabs>\n      \n      <!-- Contrast checker -->\n      <div class=\"pt-2 space-y-2\">\n        <div class=\"text-xs font-medium\">Contrast ratio: {contrastRatio.toFixed(2)}</div>\n        <div class=\"flex space-x-2\">\n          <div class=\"text-xs px-2 py-1 rounded-sm {meetsAA ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}\">\n            AA {meetsAA ? '✓' : '✗'}\n          </div>\n          <div class=\"text-xs px-2 py-1 rounded-sm {meetsAAA ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}\">\n            AAA {meetsAAA ? '✓' : '✗'}\n          </div>\n        </div>\n      </div>\n      \n      <!-- Recent colors -->\n      {#if recentColors.length > 0}\n        <div class=\"pt-2\">\n          <div class=\"text-xs font-medium mb-2\">Recent colors</div>\n          <div class=\"flex flex-wrap gap-2\">\n            {#each recentColors as recentColor}\n              <button \n                class=\"w-6 h-6 rounded-md focus-visible:ring-2 focus-visible:ring-offset-2\"\n                style=\"background-color: {recentColor};\"\n                on:click={() => onChange(recentColor)}\n                aria-label=\"Use recent color {recentColor}\"\n              ></button>\n            {/each}\n          </div>\n        </div>\n      {/if}\n    </div>\n  </PopoverContent>\n</Popover>\n```",
        "testStrategy": "Test color selection in all formats (HEX, RGB, HSL, HSB). Verify contrast ratio calculation and AA/AAA indicators. Test keyboard navigation through all controls. Validate copy to clipboard functionality. Test recent colors storage and selection. Ensure all touch targets meet 44x44px minimum. Verify proper focus indicators for accessibility.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement AppearanceSection Component",
        "description": "Create the AppearanceSection component for fill, stroke, and stroke width controls.",
        "details": "Create `sections/AppearanceSection.svelte` with the following features:\n- Color picker for fill color\n- Color picker for stroke color\n- Input for stroke width\n- Handle mixed value states\n- Use FormField component for consistent styling\n- Implement proper debouncing\n\n```svelte\n<script>\n  import { Input } from \"$lib/components/ui/input\";\n  import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"$lib/components/ui/select\";\n  import FormField from \"../FormField.svelte\";\n  import ColorPickerField from \"./ColorPickerField.svelte\";\n  import { debounce } from \"lodash-es\";\n  \n  export let items = [];\n  export let onUpdate = (items) => {};\n  \n  // Compute mixed states\n  $derived.by(() => {\n    if (items.length === 0) return { fill: \"#000000\", stroke: \"#000000\", strokeWidth: 1 };\n    \n    const firstItem = items[0];\n    let fill = firstItem.fill;\n    let stroke = firstItem.stroke;\n    let strokeWidth = firstItem.strokeWidth;\n    \n    const hasMixedFill = items.some(item => item.fill !== fill);\n    const hasMixedStroke = items.some(item => item.stroke !== stroke);\n    const hasMixedStrokeWidth = items.some(item => item.strokeWidth !== strokeWidth);\n    \n    return {\n      fill: hasMixedFill ? null : fill,\n      stroke: hasMixedStroke ? null : stroke,\n      strokeWidth: hasMixedStrokeWidth ? null : strokeWidth,\n      hasMixedFill,\n      hasMixedStroke,\n      hasMixedStrokeWidth\n    };\n  });\n  \n  // Debounced update functions\n  const updateFill = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, fill: value })));\n  }, 300);\n  \n  const updateStroke = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, stroke: value })));\n  }, 300);\n  \n  const updateStrokeWidth = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, strokeWidth: parseFloat(value) })));\n  }, 300);\n</script>\n\n<div class=\"space-y-3\">\n  <FormField id=\"fill\" label=\"Fill\" isMixed={$derived.hasMixedFill}>\n    <div class=\"flex items-center space-x-2\">\n      <ColorPickerField \n        color={$derived.fill || \"#000000\"} \n        onChange={updateFill} \n      />\n      <div class=\"flex-1\">\n        <Input \n          id=\"fill\" \n          value={$derived.fill === null ? \"\" : $derived.fill} \n          placeholder={$derived.hasMixedFill ? \"—\" : \"\"}\n          on:input={(e) => updateFill(e.target.value)}\n          class=\"text-sm\"\n          aria-label=\"Fill color\"\n        />\n      </div>\n    </div>\n  </FormField>\n  \n  <FormField id=\"stroke\" label=\"Stroke\" isMixed={$derived.hasMixedStroke}>\n    <div class=\"flex items-center space-x-2\">\n      <ColorPickerField \n        color={$derived.stroke || \"#000000\"} \n        onChange={updateStroke} \n      />\n      <div class=\"flex-1\">\n        <Input \n          id=\"stroke\" \n          value={$derived.stroke === null ? \"\" : $derived.stroke} \n          placeholder={$derived.hasMixedStroke ? \"—\" : \"\"}\n          on:input={(e) => updateStroke(e.target.value)}\n          class=\"text-sm\"\n          aria-label=\"Stroke color\"\n        />\n      </div>\n    </div>\n  </FormField>\n  \n  <FormField id=\"strokeWidth\" label=\"Stroke Width\" isMixed={$derived.hasMixedStrokeWidth}>\n    <Input \n      id=\"strokeWidth\" \n      type=\"number\" \n      value={$derived.strokeWidth === null ? \"\" : $derived.strokeWidth} \n      placeholder={$derived.hasMixedStrokeWidth ? \"—\" : \"\"}\n      on:input={(e) => updateStrokeWidth(e.target.value)}\n      class=\"text-sm\"\n      aria-label=\"Stroke width in pixels\"\n      min=\"0\"\n      step=\"0.5\"\n    />\n  </FormField>\n</div>\n```",
        "testStrategy": "Test with single and multiple selections to verify mixed value handling. Test color picker integration for fill and stroke. Verify em dash displays correctly for mixed values. Test numeric input for stroke width with arrow keys. Validate debouncing with performance testing. Check accessibility of all inputs.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement EffectsSection Component",
        "description": "Create the EffectsSection component for opacity and blend mode controls.",
        "details": "Create `sections/EffectsSection.svelte` with the following features:\n- Slider and input for opacity\n- Select dropdown for blend mode\n- Handle mixed value states\n- Use FormField component for consistent styling\n- Implement proper debouncing\n\n```svelte\n<script>\n  import { Input } from \"$lib/components/ui/input\";\n  import { Slider } from \"$lib/components/ui/slider\";\n  import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"$lib/components/ui/select\";\n  import FormField from \"../FormField.svelte\";\n  import { debounce } from \"lodash-es\";\n  \n  export let items = [];\n  export let onUpdate = (items) => {};\n  \n  const blendModes = [\n    \"normal\", \"multiply\", \"screen\", \"overlay\", \"darken\", \n    \"lighten\", \"color-dodge\", \"color-burn\", \"hard-light\", \n    \"soft-light\", \"difference\", \"exclusion\"\n  ];\n  \n  // Compute mixed states\n  $derived.by(() => {\n    if (items.length === 0) return { opacity: 100, blendMode: \"normal\" };\n    \n    const firstItem = items[0];\n    let opacity = firstItem.opacity * 100; // Convert 0-1 to 0-100 for UI\n    let blendMode = firstItem.blendMode;\n    \n    const hasMixedOpacity = items.some(item => item.opacity * 100 !== opacity);\n    const hasMixedBlendMode = items.some(item => item.blendMode !== blendMode);\n    \n    return {\n      opacity: hasMixedOpacity ? null : opacity,\n      blendMode: hasMixedBlendMode ? null : blendMode,\n      hasMixedOpacity,\n      hasMixedBlendMode\n    };\n  });\n  \n  // Debounced update functions\n  const updateOpacity = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, opacity: value / 100 })));\n  }, 300);\n  \n  const updateBlendMode = debounce((value) => {\n    onUpdate(items.map(item => ({ ...item, blendMode: value })));\n  }, 300);\n</script>\n\n<div class=\"space-y-3\">\n  <FormField id=\"opacity\" label=\"Opacity\" isMixed={$derived.hasMixedOpacity}>\n    <div class=\"space-y-2\">\n      <Slider\n        id=\"opacity-slider\"\n        min={0}\n        max={100}\n        step={1}\n        value={[$derived.opacity === null ? 100 : $derived.opacity]}\n        onValueChange={([value]) => updateOpacity(value)}\n        disabled={$derived.hasMixedOpacity}\n        aria-label=\"Opacity percentage\"\n      />\n      <Input \n        id=\"opacity\" \n        type=\"number\" \n        value={$derived.opacity === null ? \"\" : $derived.opacity} \n        placeholder={$derived.hasMixedOpacity ? \"—\" : \"\"}\n        on:input={(e) => updateOpacity(parseFloat(e.target.value))}\n        class=\"text-sm\"\n        min=\"0\"\n        max=\"100\"\n        aria-label=\"Opacity percentage\"\n      />\n    </div>\n  </FormField>\n  \n  <FormField id=\"blendMode\" label=\"Blend Mode\" isMixed={$derived.hasMixedBlendMode}>\n    <Select \n      value={$derived.blendMode} \n      onValueChange={updateBlendMode}\n      disabled={$derived.hasMixedBlendMode}\n    >\n      <SelectTrigger id=\"blendMode\" aria-label=\"Blend mode\">\n        <SelectValue placeholder={$derived.hasMixedBlendMode ? \"—\" : \"Select blend mode\"} />\n      </SelectTrigger>\n      <SelectContent>\n        {#each blendModes as mode}\n          <SelectItem value={mode}>{mode}</SelectItem>\n        {/each}\n      </SelectContent>\n    </Select>\n  </FormField>\n</div>\n```",
        "testStrategy": "Test with single and multiple selections to verify mixed value handling. Test slider and input synchronization for opacity. Verify blend mode dropdown works correctly. Test mixed value states show em dash placeholder. Validate debouncing with performance testing. Check accessibility of slider, input, and select components.",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Color Utility Functions",
        "description": "Create utility functions for color conversion and contrast ratio calculation.",
        "details": "Create `utils/color.js` with the following utility functions:\n- Color format conversion (HEX, RGB, HSL, HSB)\n- Contrast ratio calculation\n- Color manipulation helpers\n\n```javascript\n/**\n * Convert hex color to RGB array\n * @param {string} hex - Hex color code\n * @returns {number[]} RGB values as [r, g, b] array\n */\nexport function hexToRgb(hex) {\n  hex = hex.replace(/^#/, '');\n  \n  if (hex.length === 3) {\n    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n  }\n  \n  const r = parseInt(hex.substring(0, 2), 16);\n  const g = parseInt(hex.substring(2, 4), 16);\n  const b = parseInt(hex.substring(4, 6), 16);\n  \n  return [r, g, b];\n}\n\n/**\n * Convert RGB values to hex color\n * @param {number[]} rgb - RGB values as [r, g, b] array\n * @returns {string} Hex color code\n */\nexport function rgbToHex(rgb) {\n  const [r, g, b] = rgb;\n  return '#' + [r, g, b].map(x => {\n    const hex = x.toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  }).join('');\n}\n\n/**\n * Convert RGB to HSL\n * @param {number[]} rgb - RGB values as [r, g, b] array\n * @returns {number[]} HSL values as [h, s, l] array\n */\nexport function rgbToHsl(rgb) {\n  let [r, g, b] = rgb.map(x => x / 255);\n  \n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  let h, s, l = (max + min) / 2;\n  \n  if (max === min) {\n    h = s = 0; // achromatic\n  } else {\n    const d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    \n    switch (max) {\n      case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n      case g: h = (b - r) / d + 2; break;\n      case b: h = (r - g) / d + 4; break;\n    }\n    \n    h /= 6;\n  }\n  \n  return [h * 360, s * 100, l * 100];\n}\n\n/**\n * Convert HSL to RGB\n * @param {number} h - Hue (0-360)\n * @param {number} s - Saturation (0-100)\n * @param {number} l - Lightness (0-100)\n * @param {number} a - Alpha (0-1)\n * @returns {number[]} RGB values as [r, g, b] array\n */\nexport function hslToRgb(h, s, l, a = 1) {\n  h /= 360;\n  s /= 100;\n  l /= 100;\n  \n  let r, g, b;\n  \n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    const hue2rgb = (p, q, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1/6) return p + (q - p) * 6 * t;\n      if (t < 1/2) return q;\n      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n      return p;\n    };\n    \n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    \n    r = hue2rgb(p, q, h + 1/3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1/3);\n  }\n  \n  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n\n/**\n * Calculate relative luminance of RGB color\n * @param {number[]} rgb - RGB values as [r, g, b] array\n * @returns {number} Relative luminance\n */\nfunction getLuminance(rgb) {\n  const [r, g, b] = rgb.map(val => {\n    val /= 255;\n    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);\n  });\n  \n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n\n/**\n * Calculate contrast ratio between two colors\n * @param {number[]} rgb1 - First RGB color as [r, g, b] array\n * @param {number[]} rgb2 - Second RGB color as [r, g, b] array\n * @returns {number} Contrast ratio (1-21)\n */\nexport function calculateContrastRatio(rgb1, rgb2) {\n  const lum1 = getLuminance(rgb1);\n  const lum2 = getLuminance(rgb2);\n  \n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n  \n  return (brightest + 0.05) / (darkest + 0.05);\n}\n```",
        "testStrategy": "Write unit tests for each color conversion function. Test edge cases like black, white, and primary colors. Verify contrast ratio calculation with known values (e.g., black on white should be 21:1). Test with invalid inputs to ensure proper error handling. Benchmark performance for large batches of color conversions.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement 8pt Grid Spacing System",
        "description": "Ensure consistent spacing throughout the component using the 8pt grid system.",
        "details": "Update all components to use consistent spacing based on the 8pt grid system:\n\n1. Create a spacing reference in a comment at the top of each component:\n```svelte\n<!-- Spacing reference (8pt grid):\n  - 4px = space-1 (0.25rem)\n  - 8px = space-2 (0.5rem)\n  - 12px = space-3 (0.75rem)\n  - 16px = space-4 (1rem)\n  - 24px = space-6 (1.5rem)\n-->\n```\n\n2. Apply consistent spacing classes throughout all components:\n   - Within components: 4-8px (space-y-1 to space-y-2)\n   - Between related fields: 12px (space-y-3)\n   - Between form sections: 16-24px (space-y-4 or space-y-6)\n   - Panel padding: 16px (p-4)\n\n3. Create a spacing audit function to verify compliance:\n```javascript\n// In development mode only\nfunction auditSpacing() {\n  const allowedSpacingClasses = [\n    'space-y-1', 'space-y-2', 'space-y-3', 'space-y-4', 'space-y-6',\n    'space-x-1', 'space-x-2', 'space-x-3', 'space-x-4', 'space-x-6',\n    'gap-1', 'gap-2', 'gap-3', 'gap-4', 'gap-6',\n    'p-1', 'p-2', 'p-3', 'p-4', 'p-6',\n    'px-1', 'px-2', 'px-3', 'px-4', 'px-6',\n    'py-1', 'py-2', 'py-3', 'py-4', 'py-6',\n    'pt-1', 'pt-2', 'pt-3', 'pt-4', 'pt-6',\n    'pb-1', 'pb-2', 'pb-3', 'pb-4', 'pb-6',\n    'pl-1', 'pl-2', 'pl-3', 'pl-4', 'pl-6',\n    'pr-1', 'pr-2', 'pr-3', 'pr-4', 'pr-6',\n    'm-1', 'm-2', 'm-3', 'm-4', 'm-6',\n    'mx-1', 'mx-2', 'mx-3', 'mx-4', 'mx-6',\n    'my-1', 'my-2', 'my-3', 'my-4', 'my-6',\n    'mt-1', 'mt-2', 'mt-3', 'mt-4', 'mt-6',\n    'mb-1', 'mb-2', 'mb-3', 'mb-4', 'mb-6',\n    'ml-1', 'ml-2', 'ml-3', 'ml-4', 'ml-6',\n    'mr-1', 'mr-2', 'mr-3', 'mr-4', 'mr-6',\n  ];\n  \n  // Find all elements with spacing classes\n  const allElements = document.querySelectorAll('*');\n  const violations = [];\n  \n  allElements.forEach(el => {\n    const classes = el.className.split(' ');\n    classes.forEach(cls => {\n      if ((cls.includes('space-') || cls.includes('gap-') || \n           cls.startsWith('p') || cls.startsWith('m')) && \n          !allowedSpacingClasses.includes(cls)) {\n        violations.push({\n          element: el,\n          class: cls,\n          suggestion: findClosestAllowedClass(cls)\n        });\n      }\n    });\n  });\n  \n  console.table(violations);\n  return violations;\n}\n\nfunction findClosestAllowedClass(cls) {\n  // Implementation to suggest closest allowed class\n}\n```\n\n4. Review and update each component to ensure spacing consistency:\n   - PropertiesPanel.svelte: `<div class=\"p-4 space-y-6\">`\n   - PanelHeader.svelte: `<div class=\"pb-4\">`\n   - FormField.svelte: `<div class=\"space-y-2\">`\n   - DimensionsSection.svelte: `<div class=\"space-y-3\">`\n   - AppearanceSection.svelte: `<div class=\"space-y-3\">`\n   - EffectsSection.svelte: `<div class=\"space-y-3\">`\n   - ColorPickerField.svelte: `<div class=\"space-y-3\">`",
        "testStrategy": "Create a visual test suite with screenshots of each component. Overlay an 8pt grid to verify alignment. Run the spacing audit function in development mode to catch violations. Create a Storybook story that showcases all spacing values used. Test responsive behavior to ensure spacing remains consistent at different viewport sizes.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Accessibility Enhancements",
        "description": "Ensure all components meet WCAG AA accessibility standards with proper focus indicators, contrast, and keyboard navigation.",
        "details": "Implement the following accessibility enhancements across all components:\n\n1. Focus Indicators:\n```css\n/* Add to your global CSS */\n.focus-visible:focus-visible {\n  outline: none;\n  box-shadow: 0 0 0 2px white, 0 0 0 4px hsl(var(--primary));\n}\n```\n\n2. Ensure all interactive elements have focus styles:\n```svelte\n<Button class=\"focus-visible:ring-2 focus-visible:ring-offset-2\" />\n```\n\n3. Add proper keyboard navigation:\n```svelte\n<!-- For numeric inputs, add arrow key handlers -->\n<script>\n  function handleKeyDown(e) {\n    if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      const newValue = parseFloat(e.target.value || 0) + 1;\n      e.target.value = newValue;\n      e.target.dispatchEvent(new Event('input'));\n    } else if (e.key === 'ArrowDown') {\n      e.preventDefault();\n      const newValue = Math.max(0, parseFloat(e.target.value || 0) - 1);\n      e.target.value = newValue;\n      e.target.dispatchEvent(new Event('input'));\n    }\n  }\n</script>\n\n<Input \n  type=\"number\" \n  on:keydown={handleKeyDown}\n  aria-label=\"Width in pixels\"\n/>\n```\n\n4. Add proper ARIA attributes:\n```svelte\n<div role=\"region\" aria-label=\"Properties panel\">\n  <!-- Content -->\n</div>\n\n<!-- For mixed values -->\n<Input \n  aria-invalid={isMixed ? \"true\" : undefined}\n  aria-describedby={isMixed ? `${id}-mixed` : undefined}\n/>\n<span id=\"{id}-mixed\" class=\"sr-only\">This field has mixed values across selection</span>\n```\n\n5. Ensure minimum touch targets:\n```svelte\n<!-- All buttons and interactive elements should be at least 44x44px -->\n<Button class=\"min-h-11 min-w-11\" />\n```\n\n6. Add contrast checking:\n```javascript\n// Add to your component setup\nimport { calculateContrastRatio } from '../utils/color';\n\n// In your component\n$derived textContrast = calculateContrastRatio(\n  hexToRgb(backgroundColor), \n  hexToRgb(textColor)\n);\n$derived meetsAA = textContrast >= 4.5;\n\n// In your template\n<div class={!meetsAA ? 'text-red-500' : ''}>\n  {!meetsAA ? 'Warning: Low contrast' : ''}\n</div>\n```\n\n7. Create an accessibility audit function:\n```javascript\nfunction auditAccessibility() {\n  // Check for missing labels\n  const inputsWithoutLabels = Array.from(document.querySelectorAll('input, select, textarea'))\n    .filter(el => {\n      const id = el.getAttribute('id');\n      if (!id) return true;\n      const label = document.querySelector(`label[for=\"${id}\"]`);\n      const ariaLabel = el.getAttribute('aria-label');\n      return !label && !ariaLabel;\n    });\n  \n  console.warn('Inputs without labels:', inputsWithoutLabels);\n  \n  // Check for small touch targets\n  const smallTouchTargets = Array.from(document.querySelectorAll('button, [role=\"button\"], a, input, select'))\n    .filter(el => {\n      const rect = el.getBoundingClientRect();\n      return rect.width < 44 || rect.height < 44;\n    });\n  \n  console.warn('Small touch targets:', smallTouchTargets);\n  \n  // More checks...\n}\n```",
        "testStrategy": "Run automated accessibility tests with Axe DevTools. Test keyboard navigation by completing all tasks without a mouse. Test with screen readers (NVDA, VoiceOver) to verify proper announcements. Verify all text meets 4.5:1 contrast ratio with WebAIM Contrast Checker. Test touch targets on mobile devices. Create a checklist of WCAG AA requirements and verify each item.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Performance Optimizations",
        "description": "Optimize component performance with proper reactive patterns, debouncing, and efficient rendering.",
        "details": "Implement the following performance optimizations:\n\n1. Use Svelte 5 runes for efficient reactivity:\n```svelte\n<script>\n  // Instead of reactive statements\n  $derived computedValue = expensiveCalculation(input);\n  \n  // For complex derivations\n  $derived.by(() => {\n    // Complex calculation that depends on multiple inputs\n    return result;\n  });\n  \n  // For side effects\n  $effect(() => {\n    // Side effect when dependencies change\n  });\n</script>\n```\n\n2. Implement proper debouncing for user inputs:\n```svelte\n<script>\n  import { debounce } from 'lodash-es';\n  \n  // Debounce expensive operations\n  const updateValue = debounce((value) => {\n    // Expensive operation\n    onUpdate(items.map(item => ({ ...item, property: value })));\n  }, 300);\n</script>\n\n<Input on:input={(e) => updateValue(e.target.value)} />\n```\n\n3. Avoid creating new objects/arrays in render path:\n```svelte\n<script>\n  // BAD: Creates new array on every render\n  $derived items = selectedItems.map(item => ({ ...item }));\n  \n  // GOOD: Only create new array when selectedItems changes\n  $derived.by(() => {\n    return selectedItems.map(item => ({ ...item }));\n  });\n</script>\n```\n\n4. Use memo for expensive calculations:\n```svelte\n<script>\n  import { memoize } from 'lodash-es';\n  \n  const calculateExpensiveValue = memoize((input) => {\n    // Expensive calculation\n    return result;\n  });\n</script>\n```\n\n5. Implement virtualization for long lists:\n```svelte\n<script>\n  import { VirtualList } from '@sveltejs/svelte-virtual-list';\n</script>\n\n<VirtualList items={longList} let:item>\n  <div>{item.name}</div>\n</VirtualList>\n```\n\n6. Add performance monitoring:\n```javascript\nfunction monitorPerformance() {\n  const measures = [];\n  \n  // Monitor input responsiveness\n  document.addEventListener('input', (e) => {\n    const start = performance.now();\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        const duration = performance.now() - start;\n        measures.push({\n          type: 'input',\n          target: e.target.id || e.target.className,\n          duration\n        });\n        if (duration > 16.67) { // More than one frame (60fps)\n          console.warn('Slow input response:', duration.toFixed(2) + 'ms', e.target);\n        }\n      });\n    });\n  });\n  \n  return {\n    getMeasures: () => measures,\n    getAverages: () => {\n      const byType = measures.reduce((acc, m) => {\n        acc[m.type] = acc[m.type] || [];\n        acc[m.type].push(m.duration);\n        return acc;\n      }, {});\n      \n      return Object.entries(byType).map(([type, durations]) => ({\n        type,\n        avg: durations.reduce((sum, d) => sum + d, 0) / durations.length,\n        max: Math.max(...durations),\n        min: Math.min(...durations)\n      }));\n    },\n    clear: () => {\n      measures.length = 0;\n    }\n  };\n}\n\nconst perfMonitor = monitorPerformance();\n// Access with: perfMonitor.getAverages()\n```",
        "testStrategy": "Profile with Chrome DevTools Performance tab to ensure 60fps rendering. Create a benchmark test that measures time for common operations. Test with large datasets to verify scaling performance. Monitor memory usage to check for leaks. Test debouncing by rapidly changing values. Create a performance regression test suite to compare before/after optimizations.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Mixed Selection Handling",
        "description": "Create a system for handling mixed values across multiple selections with proper visual indicators.",
        "details": "Implement mixed selection handling across all components:\n\n1. Create a utility function for detecting mixed values:\n```javascript\n/**\n * Check if a property has mixed values across selected items\n * @param {Array} items - Selected items\n * @param {string} property - Property name to check\n * @returns {Object} Object with value and isMixed flag\n */\nexport function getMixedValue(items, property) {\n  if (!items || items.length === 0) return { value: null, isMixed: false };\n  \n  const firstValue = items[0][property];\n  const isMixed = items.some(item => item[property] !== firstValue);\n  \n  return {\n    value: isMixed ? null : firstValue,\n    isMixed\n  };\n}\n```\n\n2. Use em dash for mixed values in inputs:\n```svelte\n<script>\n  import { getMixedValue } from '../utils/mixed-values';\n  \n  export let items = [];\n  \n  $derived mixedWidth = getMixedValue(items, 'width');\n</script>\n\n<Input \n  value={mixedWidth.isMixed ? \"\" : mixedWidth.value} \n  placeholder={mixedWidth.isMixed ? \"—\" : \"\"}\n/>\n```\n\n3. Add helper text for mixed values:\n```svelte\n<FormField id=\"width\" label=\"Width\" isMixed={mixedWidth.isMixed}>\n  <Input ... />\n</FormField>\n```\n\n4. Handle updates to apply to all selected items:\n```svelte\n<script>\n  function updateWidth(value) {\n    // Apply to all selected items\n    onUpdate(items.map(item => ({ ...item, width: parseFloat(value) })));\n  }\n</script>\n\n<Input on:input={(e) => updateWidth(e.target.value)} />\n```\n\n5. Display selection count in header:\n```svelte\n<PanelHeader \n  selectionCount={items.length} \n  selectionType={items[0]?.type || \"\"}\n/>\n```\n\n6. Use $derived.by for efficient mixed state computation:\n```svelte\n<script>\n  $derived.by(() => {\n    if (items.length === 0) return { width: 0, height: 0, hasMixed: false };\n    \n    const firstItem = items[0];\n    let width = firstItem.width;\n    let height = firstItem.height;\n    \n    const hasMixedWidth = items.some(item => item.width !== width);\n    const hasMixedHeight = items.some(item => item.height !== height);\n    \n    return {\n      width: hasMixedWidth ? null : width,\n      height: hasMixedHeight ? null : height,\n      hasMixedWidth,\n      hasMixedHeight\n    };\n  });\n</script>\n```",
        "testStrategy": "Test with multiple selections having different values to verify em dash display. Test updating a mixed value field and verify it applies to all selected items. Test with edge cases like empty selection, single selection, and large selections. Verify helper text appears correctly for mixed values. Test performance with large selections to ensure efficient computation.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Visual Regression Tests",
        "description": "Implement visual regression testing to compare before/after screenshots and ensure visual consistency.",
        "details": "Set up visual regression testing with the following steps:\n\n1. Install required dependencies:\n```bash\nnpm install -D @playwright/test playwright\n```\n\n2. Create a visual test configuration:\n```javascript\n// playwright.config.js\nimport { defineConfig } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './tests',\n  use: {\n    baseURL: 'http://localhost:5173',\n    screenshot: 'on',\n    viewport: { width: 1280, height: 720 },\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { browserName: 'chromium' },\n    },\n  ],\n});\n```\n\n3. Create visual regression test cases:\n```javascript\n// tests/visual.spec.js\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Properties Panel Visual Tests', () => {\n  test('empty state renders correctly', async ({ page }) => {\n    await page.goto('/test-properties-panel?selection=none');\n    await expect(page).toHaveScreenshot('properties-panel-empty.png', {\n      maxDiffPixelRatio: 0.01\n    });\n  });\n  \n  test('single selection renders correctly', async ({ page }) => {\n    await page.goto('/test-properties-panel?selection=single');\n    await expect(page).toHaveScreenshot('properties-panel-single.png', {\n      maxDiffPixelRatio: 0.01\n    });\n  });\n  \n  test('multiple selection with mixed values renders correctly', async ({ page }) => {\n    await page.goto('/test-properties-panel?selection=mixed');\n    await expect(page).toHaveScreenshot('properties-panel-mixed.png', {\n      maxDiffPixelRatio: 0.01\n    });\n  });\n  \n  test('color picker opens and renders correctly', async ({ page }) => {\n    await page.goto('/test-properties-panel?selection=single');\n    await page.click('button[aria-label=\"Select color\"]');\n    // Wait for animation\n    await page.waitForTimeout(300);\n    await expect(page).toHaveScreenshot('color-picker-open.png', {\n      maxDiffPixelRatio: 0.01\n    });\n  });\n  \n  test('accordion sections expand/collapse correctly', async ({ page }) => {\n    await page.goto('/test-properties-panel?selection=single');\n    // Collapse first section\n    await page.click('button[aria-controls*=\"dimensions\"]');\n    await page.waitForTimeout(300);\n    await expect(page).toHaveScreenshot('accordion-collapsed.png', {\n      maxDiffPixelRatio: 0.01\n    });\n  });\n});\n```\n\n4. Create a test page with different states:\n```svelte\n<!-- src/routes/test-properties-panel/+page.svelte -->\n<script>\n  import { onMount } from 'svelte';\n  import PropertiesPanel from '$lib/components/properties-panel/PropertiesPanel.svelte';\n  \n  let selection = [];\n  \n  onMount(() => {\n    const params = new URLSearchParams(window.location.search);\n    const selectionType = params.get('selection');\n    \n    if (selectionType === 'single') {\n      selection = [{\n        id: 1,\n        type: 'rectangle',\n        width: 100,\n        height: 80,\n        x: 50,\n        y: 50,\n        rotation: 0,\n        fill: '#FF5733',\n        stroke: '#000000',\n        strokeWidth: 1,\n        opacity: 1,\n        blendMode: 'normal'\n      }];\n    } else if (selectionType === 'mixed') {\n      selection = [\n        {\n          id: 1,\n          type: 'rectangle',\n          width: 100,\n          height: 80,\n          x: 50,\n          y: 50,\n          rotation: 0,\n          fill: '#FF5733',\n          stroke: '#000000',\n          strokeWidth: 1,\n          opacity: 1,\n          blendMode: 'normal'\n        },\n        {\n          id: 2,\n          type: 'rectangle',\n          width: 200,\n          height: 150,\n          x: 200,\n          y: 100,\n          rotation: 45,\n          fill: '#3366FF',\n          stroke: '#000000',\n          strokeWidth: 2,\n          opacity: 0.8,\n          blendMode: 'multiply'\n        }\n      ];\n    }\n  });\n  \n  function handleUpdate(updatedItems) {\n    selection = updatedItems;\n  }\n</script>\n\n<div class=\"w-80 h-screen\">\n  <PropertiesPanel selectedItems={selection} onUpdateItems={handleUpdate} />\n</div>\n```\n\n5. Add npm scripts for running tests:\n```json\n{\n  \"scripts\": {\n    \"test:visual\": \"playwright test\",\n    \"test:visual:update\": \"playwright test --update-snapshots\"\n  }\n}\n```",
        "testStrategy": "Run visual regression tests before and after major changes. Compare screenshots to detect unintended visual changes. Update snapshots when intentional changes are made. Test across different viewport sizes to ensure responsive design. Create a CI pipeline to run visual tests automatically on pull requests.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Migration Strategy and Final Testing",
        "description": "Create a migration plan to replace the old component and perform final testing.",
        "details": "Implement the migration strategy as outlined in the PRD:\n\n1. Create a feature flag to toggle between old and new components:\n```javascript\n// src/lib/config.js\nexport const FEATURES = {\n  NEW_PROPERTIES_PANEL: true\n};\n```\n\n2. Create a wrapper component that conditionally renders old or new:\n```svelte\n<!-- src/lib/components/PropertiesPanelWrapper.svelte -->\n<script>\n  import { FEATURES } from '$lib/config';\n  import OldPropertiesPanel from './PropertiesPanel.svelte';\n  import NewPropertiesPanel from './properties-panel/PropertiesPanel.svelte';\n  \n  export let selectedItems = [];\n  export let onUpdateItems = (items) => {};\n</script>\n\n{#if FEATURES.NEW_PROPERTIES_PANEL}\n  <NewPropertiesPanel \n    selectedItems={selectedItems} \n    onUpdateItems={onUpdateItems} \n  />\n{:else}\n  <OldPropertiesPanel \n    selectedItems={selectedItems} \n    onUpdateItems={onUpdateItems} \n  />\n{/if}\n```\n\n3. Create a comprehensive test plan:\n```markdown\n# Properties Panel Migration Test Plan\n\n## Functional Testing\n- [ ] All inputs correctly display and update values\n- [ ] Mixed selection handling works correctly\n- [ ] Color picker functions properly\n- [ ] Accordion sections expand/collapse\n- [ ] All buttons and interactive elements work\n\n## Accessibility Testing\n- [ ] Run Axe DevTools audit (target: zero violations)\n- [ ] Test keyboard navigation (tab order, focus indicators)\n- [ ] Test with screen readers (NVDA, VoiceOver)\n- [ ] Verify color contrast meets WCAG AA (4.5:1)\n- [ ] Test touch targets (44x44px minimum)\n\n## Visual Testing\n- [ ] Compare before/after screenshots\n- [ ] Verify 8pt grid spacing consistency\n- [ ] Check for excessive borders (target: no more than 3)\n- [ ] Verify typography scale consistency\n\n## Performance Testing\n- [ ] Profile with Chrome DevTools (target: 60fps)\n- [ ] Test with large selections (100+ items)\n- [ ] Verify debouncing works correctly\n- [ ] Check memory usage over time\n\n## Browser/Device Testing\n- [ ] Test on Chrome, Firefox, Safari\n- [ ] Test on mobile devices\n- [ ] Test at different viewport sizes\n```\n\n4. Create a rollback plan:\n```markdown\n# Rollback Plan\n\n1. If issues are discovered after deployment:\n   - Set `FEATURES.NEW_PROPERTIES_PANEL = false` in config\n   - Deploy hotfix\n\n2. For data migration issues:\n   - Implement data transformation function to convert between formats\n   - Add version field to saved data\n\n3. For performance regressions:\n   - Identify bottleneck through profiling\n   - Implement targeted fix or rollback\n```\n\n5. Final deployment steps:\n```markdown\n# Deployment Checklist\n\n1. Run all tests (unit, integration, visual, accessibility)\n2. Deploy with feature flag OFF to production\n3. Enable for internal users and gather feedback\n4. Fix any reported issues\n5. Gradually roll out to all users (10% → 25% → 50% → 100%)\n6. Monitor error rates and performance\n7. After 2 weeks with no issues, remove old component\n```",
        "testStrategy": "Create a comprehensive test matrix covering all functionality. Perform A/B testing with internal users to gather feedback. Run accessibility audits on both old and new components for comparison. Conduct performance benchmarks comparing old vs new. Test the feature flag toggle to ensure smooth switching. Create a rollback drill to verify emergency procedures.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-19T05:41:02.580Z",
      "updated": "2025-10-19T05:49:56.485Z",
      "description": "Tasks for master context"
    }
  }
}